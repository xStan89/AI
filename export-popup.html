<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Research Tool - Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;700&display=swap');
    
    :root {
      --text-black: #020202;
      --near-black: #383838;
      --bg-white: #d3d3d3;
      --panel-grey: #C2C2C2;
      --main-yellow: #FFD241;
      --shadow-grey: #9E9E9E;
      --light-yellow: #FFEDB4;
      --shadow-yellow: #DEB555;
      --light-grey:  #d8d8d8;
      --highlight-white: #FFFFFF;
      --error-red: #dc2626;
      --font-family: 'Rubik', Arial, Helvetica, sans-serif;
    }
    
    html,body { 
      height:100%; 
      margin:0; 
      font-family: var(--font-family); 
      background:var(--bg-white); 
    }
    #wrap { display:flex; height:100vh; overflow:hidden; }

    /* GRAPH AREA */
    #graph-area { position:relative; flex:1; background:var(--bg-white); }
    canvas { width:100%; height:100%; display:block; background:var(--bg-white); }

    /* LOGO */
    #logo {
      position: absolute;
      bottom: 6px;
      right: 22px;
      z-index: 10;
      opacity: 1;
      pointer-events: none;
    }
    
    #logo img {
      height: 55px;
      width: auto;
    }

    /* ZOOM CONTROLS - moved to top left */
    #zoom-controls {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }

    /* SEARCH CONTROLS - top right */
    #top-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 12px;
      z-index: 10;
    }
    
    .zoom-btn {
      padding: 6px 8px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: var(--panel-grey);
      color: var(--text-black);
      font-size: 18px;
      font-weight: bold;
      min-width: 35px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: var(--font-family);
    }
    
    .zoom-btn:hover {
      background: var(--light-yellow);
    }

    /* MODAL WINDOW */
    #info-modal {
      position: fixed;
      right: 20px;
      bottom: 20px;
      width: 292px;
      height: 584px;
      background: var(--panel-grey);
      color: var(--text-black);
      padding: 12px;
      box-sizing: border-box;
      display: none;
      flex-direction: column;
      border: 2px solid var(--shadow-grey);
      border-radius: 8px;
      font-size: 13px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      z-index: 1000;
    }

    #info-modal.visible {
      display: flex;
    }

    #modal-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: none;
      background: var(--main-yellow);
      color: var(--text-black);
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      line-height: 1;
      padding: 0;
    }

    #modal-close:hover {
      background: var(--light-yellow);
    }
    
    #controls { 
      display: flex; 
      gap: 8px; 
      align-items: center; 
    }
    #search-box { display: flex; gap: 6px; position: relative; }
    #search-input { 
      width: 200px;
      padding: 6px 8px; 
      border-radius: 4px; 
      border: 1px solid var(--shadow-grey); 
      background: rgba(255,255,255,0.9); 
      color: var(--text-black);
      font-family: var(--font-family); 
    }
    #search-btn { 
      padding: 8px 12px; 
      border-radius: 4px; 
      border: none; 
      cursor: pointer; 
      background: var(--main-yellow); 
      color: var(--text-black);
      font-family: var(--font-family);
      font-weight: bold;
      white-space: nowrap;
    }
    
    #search-btn:hover {
      background: var(--light-yellow);
    }

    #suggestions { 
      position: absolute;
      top: 100%;
      right: 0;
      width: 280px;
      background: rgba(255,255,255,0.95); 
      border: 1px solid var(--shadow-grey); 
      max-height: 160px; 
      overflow: auto; 
      display: none; 
      padding: 6px; 
      border-radius: 4px;
      margin-top: 4px;
      z-index: 1000;
    }
    .suggestion { 
      padding: 6px; 
      cursor: pointer; 
      border-bottom: 1px dashed var(--shadow-grey); 
    }
    .suggestion:hover { 
      background: var(--light-yellow); 
    }

    #node-info { 
      margin-top: 32px;
      padding: 8px; 
      background: var(--panel-grey); 
      border-radius: 6px; 
      flex-shrink: 0;
      overflow-y: auto;
      max-height: 200px;
    }
    #node-title { font-weight: 700; }
    .muted { color: var(--shadow-grey); font-weight: 700; }

    #node-links {
      margin-top: 8px;
      flex-shrink: 0;
    }

    #connections-box {
      margin-top: -6px;
      background: var(--light-grey);
      border-radius: 6px;
      padding: 6px;
      overflow: auto;
      border: 1px solid var(--shadow-grey);
      flex: 1;
      min-height: 0;
    }
    .conn-item {
      padding: 6px;
      cursor: pointer;
      font-size: 13px;
      color: var(--text-black);
      border-bottom: 1px dashed var(--shadow-grey);
    }
    .conn-item:hover { 
      background: var(--light-yellow); 
    }

    #msg { 
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 4px;
      color: var(--error-red); 
      font-size: 13px; 
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      white-space: nowrap;
    }

    /* LOADING OVERLAY */
    #loading-overlay {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 10px;
      background: rgba(250,250,250,0.9);
      z-index: 99999;
      font-size: 16px;
      color: var(--text-black);
    }
    .spinner {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: 8px solid var(--shadow-grey);
      border-left-color: var(--main-yellow);
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* responsive */
    @media (max-width: 900px) { 
      #info-panel { width: 260px; min-width: 260px; max-width: 260px; } 
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="graph-area">
      <canvas id="canvas"></canvas>
      
      <div id="logo">
        <img src="https://i.ibb.co/RXfZbS8/De-Smog-Logo-small.png" alt="Logo">
      </div>
      
      <!-- Zoom controls at top left -->
      <div id="zoom-controls">
        <button id="zoom-in" class="zoom-btn" title="Zoom In">+</button>
        <button id="zoom-out" class="zoom-btn" title="Zoom Out">−</button>
        <button id="zoom-reset" class="zoom-btn" title="Reset Zoom">↻</button>
      </div>
      
      <!-- Search controls at top right -->
      <div id="top-controls">
        <div id="controls">
          <div id="search-box">
            <input id="search-input" placeholder="Search..." />
            <button id="search-btn">Search</button>
            <div id="suggestions"></div>
            <div id="msg"></div>
          </div>
        </div>
      </div>

      <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Loading data...</div>
      </div>
    </div>

    <!-- Modal -->
    <div id="info-modal">
      <button id="modal-close" title="Close">×</button>
      
      <div id="node-info">
        <div id="node-title">Select a node to view details</div>
        <div id="node-meta" class="muted" style="margin-top:6px;"></div>
      </div>

      <div id="node-links"></div>

      <div id="connections-box"></div>
    </div>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <script>
  /************************************************************************
   * CONFIG
   ************************************************************************/
  const CONFIG = {
    colorPalette: d3.schemeTableau10,
    pointOpacity: 1.0,
    unconnectedOpacity: 0.15,
    linkOpacityNoSelection: 0.8,
    linkOpacitySelected: 0.8,
    labelFontSize: 17,
    labelBoxPadding: 4,
    labelOffsetY: 4,
    labelBoxOpacity: 0.6,
    gridSize: 25,
    dragDelayMs: 600,
    force: {
      linkDistance: 30,
      linkStrength: 0.8,
      chargeStrength: -300,
      collisionPadding: 10,
      velocityDecay: 0.1
    },
    showImages: true,
    maxSuggestions: 25,
    zoomMin: 0.2,
    zoomMax: 5.0,
    zoomStep: 0.2,
    // DATA FOLDER - Change this path to point to your data folder
    dataFolder: 'data/'
  };

  const PADDING = 80;

  // Modal configuration
  const MODAL_CONFIG = {
    width: 292,
    height: 584,
    padding: 20
  };

  let savedZoomBeforeModal = null;

  // Default Formatting Settings
  let formattingSettings = {
    nodeColor: '#000000',
    nodeHoverColor: '#FFD241',
    outlineColor: '#E3E3E3',
    outlineHoverColor: '#FFD241',
    outlineThickness: 4,
    outlineHoverThickness: 5,
    lineColor: '#000000',
    lineHoverColor: '#FFD241',
    lineThickness: 3,
    lineHoverThickness: 5,
    backgroundColor: '#E3E3E3',
    nodeSizeMode: 'connections',
    customNodeSize: 30,
    minNodeSize: 12,
    maxNodeSize: 80,
    sizeScale: 1.0
  };

  // Global state
  let nodes = [];
  let animationTime = 0;
  let animationScheduled = false;
  let links = [];
  let nodeById = new Map();
  let adjacency = new Map();
  let connectionSources = new Map();
  let nameIndex = [];
  let simulation = null;
  let selectedNode = null;
  let hoveredNode = null;
  let isDragging = false;
  let isDraggingNode = false;
  let draggedNode = null;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartPanX = 0;
  let dragStartPanY = 0;
  let mouseDownNode = null;
  let mouseDownTime = 0;
  let dragDelayTimer = null;
  let didDrag = false;

  // Conditional Formatting State
  let conditionalFormats = [];

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  
  let zoomLevel = 1.0;
  let panX = 0;
  let panY = 0;

  const loadingOverlay = document.getElementById('loading-overlay');
  const loadingText = document.getElementById('loading-text');
  const searchInput = document.getElementById('search-input');
  const searchBtn = document.getElementById('search-btn');
  const suggestionsEl = d3.select('#suggestions');
  const nodeTitleEl = d3.select('#node-title');
  const nodeMetaEl = d3.select('#node-meta');
  const nodeLinkEl = d3.select('#node-links');
  const connectionsBox = document.getElementById('connections-box');
  const msgEl = d3.select('#msg');
  const zoomInBtn = document.getElementById('zoom-in');
  const zoomOutBtn = document.getElementById('zoom-out');
  const zoomResetBtn = document.getElementById('zoom-reset');

  /************************************************************************
   * CANVAS SETUP
   ************************************************************************/
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const hiResScale = devicePixelRatio * 1.5;
    canvas.width  = Math.max(600, Math.floor(rect.width  * hiResScale));
    canvas.height = Math.max(400, Math.floor(rect.height * hiResScale));
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  
  // Debounce timer for resize
  let resizeDebounceTimer = null;
  
  window.addEventListener('resize', () => { 
    resizeCanvas(); 
    
    // Immediate rescale for responsiveness
    if (nodes.length > 0 && originalDataBounds) {
      scaleNodesToFit();
    }
    
    if (simulation && simulation.force) { 
      const c = simulation.force('center'); 
      if (c) {
        c.x((canvas.width/(devicePixelRatio))/2);
        c.y((canvas.height/(devicePixelRatio))/2);
      }
    } 
    render();
    
    // Debounced final adjustment
    if (resizeDebounceTimer) clearTimeout(resizeDebounceTimer);
    resizeDebounceTimer = setTimeout(() => {
      if (nodes.length > 0 && originalDataBounds) {
        scaleNodesToFit();
        render();
      }
    }, 100);
  });
  
  resizeCanvas();

  /************************************************************************
   * NODE SIZING
   ************************************************************************/
  function updateNodeSizes() {
    if (nodes.length === 0) return;
    
    const connectionCounts = nodes.map(n => (adjacency.get(n.id) || new Set()).size);
    const maxConnections = Math.max(...connectionCounts, 1);
    const minConnections = Math.min(...connectionCounts, 0);
    
    nodes.forEach(n => {
      const conns = (adjacency.get(n.id) || new Set()).size;
      
      if (formattingSettings.nodeSizeMode === 'custom') {
        n.baseR = formattingSettings.customNodeSize;
      } else {
        const normalized = maxConnections > minConnections 
          ? (conns - minConnections) / (maxConnections - minConnections)
          : 0.5;
        
        n.baseR = formattingSettings.minNodeSize + normalized * (formattingSettings.maxNodeSize - formattingSettings.minNodeSize);
      }
      n.r = n.baseR;
    });
    
    applyNodeSizeScale();
  }
  
  function applyNodeSizeScale() {
    const scale = formattingSettings.sizeScale;
    nodes.forEach(n => {
      const format = getNodeFormat(n);
      if (format?.sizeEnabled && format?.nodeSize) {
        n.r = (format.nodeSize * scale) / 2;
      } else {
        n.r = (n.baseR || 15) * scale;
      }
    });
  }

  /************************************************************************
   * CONDITIONAL FORMATTING
   ************************************************************************/
  function invalidateFormatCache() {
    nodes.forEach(n => { n._cachedFormat = undefined; });
    links.forEach(l => { l._cachedFormat = undefined; });
  }

  function getNodeFormat(node) {
    if (node._cachedFormat !== undefined) return node._cachedFormat;
    
    for (const rule of conditionalFormats) {
      if (rule.type === 'entity') {
        if (rule.targets.includes(node.id)) {
          node._cachedFormat = rule;
          return rule;
        }
      } else if (rule.type === 'category') {
        const category = node.raw && node.raw['Category'];
        if (rule.targets.includes(category)) {
          node._cachedFormat = rule;
          return rule;
        }
      }
    }
    
    node._cachedFormat = null;
    return null;
  }

  function getLinkFormat(link) {
    if (link._cachedFormat) return link._cachedFormat;
    
    const sourceFormat = getNodeFormat(link.source);
    const targetFormat = getNodeFormat(link.target);
    
    if (sourceFormat && targetFormat) {
      const sourceIndex = conditionalFormats.indexOf(sourceFormat);
      const targetIndex = conditionalFormats.indexOf(targetFormat);
      link._cachedFormat = sourceIndex <= targetIndex ? sourceFormat : targetFormat;
    } else if (sourceFormat) {
      link._cachedFormat = sourceFormat;
    } else if (targetFormat) {
      link._cachedFormat = targetFormat;
    } else {
      link._cachedFormat = null;
    }
    
    return link._cachedFormat;
  }

  /************************************************************************
   * AUTO-LOAD DATA FROM FOLDER
   ************************************************************************/
  async function autoLoadData() {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Loading data...';
    
    try {
      const entitiesUrl = CONFIG.dataFolder + 'Entities.csv';
      const connectionsUrl = CONFIG.dataFolder + 'Connections.csv';
      const formattingUrl = CONFIG.dataFolder + 'Formatting.csv';
      
      // Fetch entities and connections (required)
      const [entitiesResponse, connectionsResponse] = await Promise.all([
        fetch(entitiesUrl),
        fetch(connectionsUrl)
      ]);
      
      if (!entitiesResponse.ok || !connectionsResponse.ok) {
        throw new Error('Could not load required data files (Entities.csv and Connections.csv)');
      }
      
      const entitiesText = await entitiesResponse.text();
      const connectionsText = await connectionsResponse.text();
      
      const entitiesData = Papa.parse(entitiesText, { header: true, skipEmptyLines: true }).data;
      const connectionsData = Papa.parse(connectionsText, { header: true, skipEmptyLines: true }).data;
      
      // Try to load formatting (optional)
      try {
        const formattingResponse = await fetch(formattingUrl);
        if (formattingResponse.ok) {
          const formattingText = await formattingResponse.text();
          const formattingData = Papa.parse(formattingText, { header: true, skipEmptyLines: true }).data;
          loadFormattingData(formattingData);
        }
      } catch (e) {
        // Formatting file is optional, ignore errors
      }
      
      loadSession(entitiesData, connectionsData);
      
    } catch (err) {
      console.error('Failed to load data:', err);
      loadingText.textContent = 'Error: ' + err.message;
      setTimeout(() => {
        loadingOverlay.style.display = 'none';
      }, 3000);
    }
  }

  function loadFormattingData(data) {
    if (!data || data.length === 0) return;
    
    conditionalFormats = [];
    
    data.forEach(row => {
      if (row.RuleType === 'Default' || !row.RuleType) {
        if (row.NodeColor) formattingSettings.nodeColor = row.NodeColor;
        if (row.NodeHoverColor) formattingSettings.nodeHoverColor = row.NodeHoverColor;
        if (row.LineColor) formattingSettings.lineColor = row.LineColor;
        if (row.LineHoverColor) formattingSettings.lineHoverColor = row.LineHoverColor;
        if (row.LineThickness) formattingSettings.lineThickness = parseFloat(row.LineThickness);
        if (row.LineHoverThickness) formattingSettings.lineHoverThickness = parseFloat(row.LineHoverThickness);
        if (row.OutlineColor) formattingSettings.outlineColor = row.OutlineColor;
        if (row.OutlineHoverColor) formattingSettings.outlineHoverColor = row.OutlineHoverColor;
        if (row.OutlineThickness) formattingSettings.outlineThickness = parseFloat(row.OutlineThickness);
        if (row.OutlineHoverThickness) formattingSettings.outlineHoverThickness = parseFloat(row.OutlineHoverThickness);
        if (row.BackgroundColor) {
          formattingSettings.backgroundColor = row.BackgroundColor;
          document.documentElement.style.setProperty('--bg-white', row.BackgroundColor);
        }
        if (row.SizeMode) formattingSettings.nodeSizeMode = row.SizeMode;
        if (row.CustomNodeSize) formattingSettings.customNodeSize = parseFloat(row.CustomNodeSize);
      } else if (row.RuleType === 'Entity' || row.RuleType === 'Category') {
        const targets = row.Targets ? row.Targets.split('|').map(t => t.trim()).filter(t => t) : [];
        
        conditionalFormats.push({
          type: row.RuleType.toLowerCase(),
          name: row.RuleName || 'Unnamed Rule',
          order: parseInt(row.Order) || conditionalFormats.length,
          targets: targets,
          nodeEnabled: row.NodeEnabled === 'true',
          nodeColor: row.NodeColor || null,
          outlineEnabled: row.OutlineEnabled === 'true',
          outlineColor: row.OutlineColor || null,
          outlineThickness: row.OutlineThickness ? parseFloat(row.OutlineThickness) : null,
          sizeEnabled: row.SizeEnabled === 'true',
          nodeSize: row.NodeSize ? parseFloat(row.NodeSize) : null,
          lineEnabled: row.LineEnabled === 'true',
          lineColor: row.LineColor || null,
          lineThickness: row.LineThickness ? parseFloat(row.LineThickness) : null
        });
      }
    });
    
    conditionalFormats.sort((a, b) => a.order - b.order);
    invalidateFormatCache();
  }

  /************************************************************************
   * LOAD SESSION
   ************************************************************************/
  function loadSession(entitiesData, connectionsData) {
    // Clean headers
    entitiesData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });
    
    connectionsData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });

    // Create nodes
    nodes = entitiesData.map((d, i) => createNodeFromData(d, i));
    nodeById = new Map(nodes.map(n => [n.id, n]));

    // Create links
    processLinksData(connectionsData);

    // Build adjacency
    buildAdjacency();

    nameIndex = nodes.map(n => n.name);

    // Calculate node sizes
    updateNodeSizes();

    // Store original positions for rescaling on resize
    storeOriginalPositions();

    // Scale nodes to fit canvas (replaces centerNodesInCanvas)
    scaleNodesToFit();

    // Load images
    loadAllImages();

    // Start physics
    updatePhysics();

    loadingOverlay.style.display = 'none';
  }

  // Store original data for rescaling on resize
  let originalNodePositions = new Map();
  let originalDataBounds = null;
  let currentScaleFactor = 1.0;
  
  function storeOriginalPositions() {
    originalNodePositions.clear();
    nodes.forEach(n => {
      const x = n.raw && !isNaN(parseFloat(n.raw['X'])) ? parseFloat(n.raw['X']) : n.x;
      const y = n.raw && !isNaN(parseFloat(n.raw['Y'])) ? parseFloat(n.raw['Y']) : n.y;
      originalNodePositions.set(n.id, { 
        x, 
        y, 
        isFixed: n.isFixed,
        baseR: n.baseR || formattingSettings.minNodeSize
      });
    });
    
    // Calculate and store original data bounds
    const positionedNodes = nodes.filter(n => n.isFixed || (n.raw && !isNaN(parseFloat(n.raw['X']))));
    if (positionedNodes.length >= 2) {
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      
      positionedNodes.forEach(n => {
        const orig = originalNodePositions.get(n.id);
        minX = Math.min(minX, orig.x);
        maxX = Math.max(maxX, orig.x);
        minY = Math.min(minY, orig.y);
        maxY = Math.max(maxY, orig.y);
      });
      
      originalDataBounds = {
        minX, maxX, minY, maxY,
        width: maxX - minX,
        height: maxY - minY,
        centerX: (minX + maxX) / 2,
        centerY: (minY + maxY) / 2
      };
    }
  }

  function scaleNodesToFit() {
    if (nodes.length === 0) return;
    
    // Need original positions and bounds
    if (originalNodePositions.size === 0 || !originalDataBounds) {
      centerNodesInCanvas();
      return;
    }
    
    const dataWidth = originalDataBounds.width;
    const dataHeight = originalDataBounds.height;
    
    if (dataWidth === 0 || dataHeight === 0) {
      centerNodesInCanvas();
      return;
    }
    
    // Calculate available canvas space (with fixed margin for padding)
    const margin = PADDING + 40; // Fixed margin for largest expected scaled node
    
    const canvasW = (canvas.width / devicePixelRatio) - margin * 2;
    const canvasH = (canvas.height / devicePixelRatio) - margin * 2;
    
    // Calculate scale factor (preserving aspect ratio)
    const scaleX = canvasW / dataWidth;
    const scaleY = canvasH / dataHeight;
    currentScaleFactor = Math.min(scaleX, scaleY);
    
    // Clamp scale factor to reasonable bounds
    currentScaleFactor = Math.max(0.1, Math.min(currentScaleFactor, 3.0));
    
    // Calculate canvas center
    const canvasCenterX = (canvas.width / devicePixelRatio) / 2;
    const canvasCenterY = (canvas.height / devicePixelRatio) / 2;
    
    // Apply transformation to all nodes
    nodes.forEach(n => {
      const orig = originalNodePositions.get(n.id);
      if (!orig) return;
      
      // Scale position relative to data center, then translate to canvas center
      const newX = (orig.x - originalDataBounds.centerX) * currentScaleFactor + canvasCenterX;
      const newY = (orig.y - originalDataBounds.centerY) * currentScaleFactor + canvasCenterY;
      
      n.x = newX;
      n.y = newY;
      
      if (n.isFixed) {
        n.fx = newX;
        n.fy = newY;
      }
      
      if (n.unfixedX !== null) {
        n.unfixedX = newX;
        n.unfixedY = newY;
      }
      
      // Scale node radius (baseR stays constant, r is the displayed size)
      n.r = orig.baseR * currentScaleFactor;
    });
    
    // Update collision force with new radii
    if (simulation && simulation.force('collision')) {
      simulation.force('collision').radius(d => d.r + CONFIG.force.collisionPadding);
    }
  }

  function centerNodesInCanvas() {
    if (nodes.length === 0) return;
    
    // Calculate bounding box of all nodes
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    
    nodes.forEach(n => {
      if (n.x < minX) minX = n.x;
      if (n.x > maxX) maxX = n.x;
      if (n.y < minY) minY = n.y;
      if (n.y > maxY) maxY = n.y;
    });
    
    // Calculate centroid of nodes
    const nodesCenterX = (minX + maxX) / 2;
    const nodesCenterY = (minY + maxY) / 2;
    
    // Calculate canvas center
    const canvasCenterX = (canvas.width / devicePixelRatio) / 2;
    const canvasCenterY = (canvas.height / devicePixelRatio) / 2;
    
    // Calculate offset to center nodes
    const offsetX = canvasCenterX - nodesCenterX;
    const offsetY = canvasCenterY - nodesCenterY;
    
    // Shift all nodes
    nodes.forEach(n => {
      n.x += offsetX;
      n.y += offsetY;
      if (n.fx !== null) n.fx += offsetX;
      if (n.fy !== null) n.fy += offsetY;
      if (n.unfixedX !== null) n.unfixedX += offsetX;
      if (n.unfixedY !== null) n.unfixedY += offsetY;
    });
  }

  function createNodeFromData(d, i) {
    const id = d['Entity Name'] ? String(d['Entity Name']).trim() : `__P_${i}`;
    
    const show = d['Show'] === undefined ? true : (d['Show'] === 'true' || d['Show'] === '1' || d['Show'] === true);
    const isFixed = d['Fixed'] === 'true' || d['Fixed'] === '1' || d['Fixed'] === true;
    const savedX = parseFloat(d['X']);
    const savedY = parseFloat(d['Y']);
    
    const x = !isNaN(savedX) && isFixed ? savedX : Math.random() * (canvas.width/(devicePixelRatio));
    const y = !isNaN(savedY) && isFixed ? savedY : Math.random() * (canvas.height/(devicePixelRatio));
    
    return {
      id, 
      name: id, 
      raw: d, 
      show,
      isFixed,
      image: d['Image'] ? d['Image'].trim() : null, 
      imageBitmap: null,
      x, 
      y,
      fx: isFixed ? x : null,
      fy: isFixed ? y : null,
      unfixedX: null,
      unfixedY: null,
      vx: 0, 
      vy: 0, 
      baseR: formattingSettings.minNodeSize,
      r: formattingSettings.minNodeSize
    };
  }

  function processLinksData(connectionsData) {
    const tmpLinks = connectionsData.map(r => ({
      sourceName: (r['A']||'').toString().trim(),
      targetName: (r['B']||'').toString().trim(),
      value: +((r['Link Size']||r['LinkSize']) || 1) || 1,
      source: (r['Source']||'').toString().trim()
    })).filter(l => l.sourceName && l.targetName);

    // Add missing nodes from links
    tmpLinks.forEach(l => {
      if (!nodeById.has(l.sourceName)) {
        const n = { 
          id: l.sourceName, 
          name: l.sourceName, 
          raw: {}, 
          show: true,
          isFixed: false,
          image: null, 
          imageBitmap: null, 
          x: Math.random() * (canvas.width/(devicePixelRatio)), 
          y: Math.random() * (canvas.height/(devicePixelRatio)), 
          fx: null,
          fy: null,
          unfixedX: null,
          unfixedY: null,
          vx: 0, 
          vy: 0, 
          baseR: formattingSettings.minNodeSize,
          r: formattingSettings.minNodeSize
        };
        nodes.push(n);
        nodeById.set(n.id, n);
      }
      if (!nodeById.has(l.targetName)) {
        const n = { 
          id: l.targetName, 
          name: l.targetName, 
          raw: {}, 
          show: true,
          isFixed: false,
          image: null, 
          imageBitmap: null, 
          x: Math.random() * (canvas.width/(devicePixelRatio)), 
          y: Math.random() * (canvas.height/(devicePixelRatio)), 
          fx: null,
          fy: null,
          unfixedX: null,
          unfixedY: null,
          vx: 0, 
          vy: 0, 
          baseR: formattingSettings.minNodeSize,
          r: formattingSettings.minNodeSize
        };
        nodes.push(n);
        nodeById.set(n.id, n);
      }
    });

    // Build links with references to node objects
    links = tmpLinks.map(l => ({
      source: nodeById.get(l.sourceName),
      target: nodeById.get(l.targetName),
      value: l.value,
      sourceUrl: l.source
    })).filter(l => l.source && l.target);
  }

  function buildAdjacency() {
    adjacency.clear();
    connectionSources.clear();
    
    links.forEach(l => {
      const sId = l.source.id;
      const tId = l.target.id;
      
      if (!adjacency.has(sId)) adjacency.set(sId, new Set());
      if (!adjacency.has(tId)) adjacency.set(tId, new Set());
      adjacency.get(sId).add(tId);
      adjacency.get(tId).add(sId);
      
      // Track source URLs for connections
      if (l.sourceUrl) {
        if (!connectionSources.has(sId)) connectionSources.set(sId, new Map());
        if (!connectionSources.has(tId)) connectionSources.set(tId, new Map());
        connectionSources.get(sId).set(tId, l.sourceUrl);
        connectionSources.get(tId).set(sId, l.sourceUrl);
      }
    });
  }

  /************************************************************************
   * IMAGE LOADING
   ************************************************************************/
  function loadAllImages() {
    const imgNodes = nodes.filter(n => n.image && CONFIG.showImages);
    Promise.allSettled(imgNodes.map(n => loadImage(n))).then(() => render());
  }

  function loadImage(node) {
    return new Promise(async resolve => {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        const resp = await fetch(node.image, { mode: 'cors', signal: controller.signal }).catch(()=>null);
        clearTimeout(timeoutId);
        if (!resp || !resp.ok) throw new Error('fetch failed');
        const blob = await resp.blob();
        if (typeof createImageBitmap === 'function') {
          const bmp = await createImageBitmap(blob, { resizeQuality: 'high' });
          node.imageBitmap = bmp;
          resolve();
        } else {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => { node.imageBitmap = img; resolve(); };
          img.onerror = () => { node.imageBitmap = null; resolve(); };
          img.src = URL.createObjectURL(blob);
        }
      } catch (err) {
        // Try direct image load as fallback
        try {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => { node.imageBitmap = img; resolve(); };
          img.onerror = () => { node.imageBitmap = null; resolve(); };
          img.src = node.image;
        } catch (e) {
          node.imageBitmap = null;
          resolve();
        }
      }
    });
  }

  /************************************************************************
   * PHYSICS SIMULATION
   ************************************************************************/
  function updatePhysics() {
    if (simulation) simulation.stop();
    
    const visibleNodes = nodes.filter(n => n.show);
    const visibleLinks = links.filter(l => l.source.show && l.target.show);
    
    if (visibleNodes.length === 0) {
      render();
      return;
    }
    
    simulation = d3.forceSimulation(visibleNodes)
      .force('link', d3.forceLink(visibleLinks)
        .id(d => d.id)
        .distance(d => Math.max(20, CONFIG.force.linkDistance / Math.sqrt(Math.max(0.5, d.value))))
        .strength(CONFIG.force.linkStrength))
      .force('charge', d3.forceManyBody().strength(CONFIG.force.chargeStrength))
      .force('center', d3.forceCenter(
        (canvas.width/(devicePixelRatio))/2, 
        (canvas.height/(devicePixelRatio))/2
      ))
      .force('collision', d3.forceCollide().radius(d => d.r + CONFIG.force.collisionPadding))
      .velocityDecay(CONFIG.force.velocityDecay)
      .on('tick', () => {
        visibleNodes.forEach(n => {
          n.x = Math.max(n.r + PADDING, Math.min((canvas.width/(devicePixelRatio)) - n.r - PADDING, n.x));
          n.y = Math.max(n.r + PADDING, Math.min((canvas.height/(devicePixelRatio)) - n.r - PADDING, n.y));
          
          // Save unfixed positions
          if (!n.isFixed) {
            n.unfixedX = n.x;
            n.unfixedY = n.y;
          }
        });
        render();
      });
    
    simulation.alpha(0.3).restart();
  }
  
  let physicsRestartTimer = null;
  function schedulePhysicsRestart() {
    if (physicsRestartTimer) clearTimeout(physicsRestartTimer);
    physicsRestartTimer = setTimeout(() => {
      updatePhysics();
    }, 100);
  }

  /************************************************************************
   * RENDERING HELPERS
   ************************************************************************/
  function clearCanvas() {
    ctx.fillStyle = formattingSettings.backgroundColor;
    ctx.fillRect(0, 0, canvas.width/(devicePixelRatio), canvas.height/(devicePixelRatio));
  }

  function applyTransform() {
    const centerX = (canvas.width/(devicePixelRatio)) / 2;
    const centerY = (canvas.height/(devicePixelRatio)) / 2;
    ctx.translate(centerX + panX, centerY + panY);
    ctx.scale(zoomLevel, zoomLevel);
    ctx.translate(-centerX, -centerY);
  }

  function roundRectPath(x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
  }

  function drawLink(l, opacity) {
    ctx.save();
    ctx.globalAlpha = opacity;
    
    // Get formatting for this link (conditional or default)
    const format = getLinkFormat(l);
    
    // Check if either end of the link is hovered
    const isHovered = hoveredNode && (l.source === hoveredNode || l.target === hoveredNode);
    
    // Use hover colors/thickness if link is connected to hovered node
    // Only use conditional format if lineEnabled is true
    const lineColor = isHovered ? formattingSettings.lineHoverColor : (format?.lineEnabled && format?.lineColor ? format.lineColor : formattingSettings.lineColor);
    const baseLineThickness = isHovered ? formattingSettings.lineHoverThickness : (format?.lineEnabled && format?.lineThickness ? format.lineThickness : formattingSettings.lineThickness);
    
    // Scale line thickness with the current scale factor
    const lineThickness = baseLineThickness * currentScaleFactor;
    
    ctx.beginPath();
    ctx.moveTo(l.source.x, l.source.y);
    ctx.lineTo(l.target.x, l.target.y);
    ctx.lineWidth = lineThickness / zoomLevel;
    ctx.strokeStyle = lineColor;
    ctx.stroke();
    ctx.restore();
  }

  function drawNode(n, opacity, showImage=true) {
    ctx.save();
    const x = n.x, y = n.y;
    
    // Get formatting for this node (conditional or default)
    const format = getNodeFormat(n);
    const isHovered = hoveredNode && n === hoveredNode;
    const isSelected = selectedNode && n === selectedNode;
    
    // Use hover colors/thickness if node is hovered OR selected
    // Only use conditional format if the respective section is enabled
    const nodeColor = isHovered ? formattingSettings.nodeHoverColor : (format?.nodeEnabled && format?.nodeColor ? format.nodeColor : formattingSettings.nodeColor);
    const outlineColor = (isHovered || isSelected) ? formattingSettings.outlineHoverColor : (format?.outlineEnabled && format?.outlineColor ? format.outlineColor : formattingSettings.outlineColor);
    const baseOutlineThickness = (isHovered || isSelected) ? formattingSettings.outlineHoverThickness : (format?.outlineEnabled && format?.outlineThickness ? format.outlineThickness : formattingSettings.outlineThickness);
    
    // Scale outline thickness with the current scale factor
    const outlineThickness = baseOutlineThickness * currentScaleFactor;
    
    // Node radius already includes scale factor from scaleNodesToFit
    const r = n.r;

    if (showImage && n.imageBitmap) {
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.clip();
      const img = n.imageBitmap;
      const iw = img.width || img.naturalWidth || 1;
      const ih = img.height || img.naturalHeight || 1;
      const target = r * 2;
      const scale = Math.max(target / iw, target / ih);
      const dw = iw * scale;
      const dh = ih * scale;
      const dx = x - dw / 2;
      const dy = y - dh / 2;
      try {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, dx, dy, dw, dh);
      } catch (e) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fillStyle = nodeColor;
        ctx.fill();
      }
      ctx.restore();
    } else {
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fillStyle = nodeColor;
      ctx.fill();
      ctx.restore();
    }

    // Draw outline with glow if this is the selected node
    ctx.save();
    ctx.globalAlpha = opacity;
    
    // Add pulsing glow for selected node
    if (selectedNode && n === selectedNode) {
      const pulsePhase = Math.sin(animationTime * 0.002) * 0.5 + 0.5; // Oscillates between 0 and 1
      const glowSize = (5 + pulsePhase * 10) * currentScaleFactor; // Scale glow with nodes
      const glowAlpha = 0.5 + pulsePhase * 0.5; // Varies between 0.5 and 1
      
      // Convert hover outline color to rgba for glow effect
      const hoverColor = formattingSettings.outlineHoverColor;
      const rr = parseInt(hoverColor.slice(1, 3), 16);
      const gg = parseInt(hoverColor.slice(3, 5), 16);
      const bb = parseInt(hoverColor.slice(5, 7), 16);
      
      ctx.shadowColor = `rgba(${rr}, ${gg}, ${bb}, ${glowAlpha})`;
      ctx.shadowBlur = glowSize;
    }
    
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.lineWidth = outlineThickness / zoomLevel;
    ctx.strokeStyle = outlineColor;
    ctx.stroke();
    ctx.restore();

    ctx.restore();
  }

  function drawLabel(n) {
    const text = n.name || '';
    if (!text) return;
    ctx.save();
    ctx.font = `${CONFIG.labelFontSize / zoomLevel}px Rubik, Arial, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const metrics = ctx.measureText(text);
    const textW = metrics.width;
    const pad = CONFIG.labelBoxPadding / zoomLevel;
    const boxW = textW + pad * 2;
    const boxH = (CONFIG.labelFontSize + 6) / zoomLevel;
    const x = n.x - boxW / 2;
    const y = n.y + n.r + CONFIG.labelOffsetY / zoomLevel;

    ctx.save();
    ctx.globalAlpha = CONFIG.labelBoxOpacity;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    roundRectPath(x, y, boxW, boxH, 6 / zoomLevel);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#111827';
    ctx.fillText(text, n.x, y + boxH / 2);
    ctx.restore();
  }

  function shouldHighlightNode(node) {
    if (!selectedNode) return true;
    const activeSet = new Set([selectedNode.id, ...(adjacency.get(selectedNode.id) || [])]);
    return activeSet.has(node.id);
  }

  /************************************************************************
   * RENDER
   ************************************************************************/
  function render() {
    animationTime = Date.now();
    clearCanvas();
    if (!nodes || nodes.length === 0) return;

    ctx.save();
    applyTransform();

    const visibleNodes = nodes.filter(n => n.show);
    const highlightedNodes = [];
    const unhighlightedNodes = [];
    
    visibleNodes.forEach(node => {
      if (shouldHighlightNode(node)) {
        highlightedNodes.push(node);
      } else {
        unhighlightedNodes.push(node);
      }
    });

    // Draw unhighlighted nodes first (dimmed)
    unhighlightedNodes.forEach(n => drawNode(n, CONFIG.unconnectedOpacity, CONFIG.showImages));

    const highlightedSet = new Set(highlightedNodes.map(n => n.id));
    const visibleLinks = links.filter(l => l.source.show && l.target.show);
    
    // Draw links - ONLY draw links between highlighted nodes when there's a selection
    if (selectedNode) {
      visibleLinks.forEach(l => {
        if (highlightedSet.has(l.source.id) && highlightedSet.has(l.target.id)) {
          drawLink(l, CONFIG.linkOpacitySelected);
        }
      });
    } else {
      visibleLinks.forEach(l => {
        drawLink(l, CONFIG.linkOpacityNoSelection);
      });
    }

    // Draw highlighted nodes on top
    highlightedNodes.forEach(n => drawNode(n, CONFIG.pointOpacity, CONFIG.showImages));

    // Draw labels for selected node and its connections
    if (selectedNode) {
      highlightedNodes.forEach(n => {
        if (adjacency.get(selectedNode.id).has(n.id) || n === selectedNode) {
          drawLabel(n);
        }
      });
    }

    // Draw label for hovered node (if not already labeled)
    if (hoveredNode && hoveredNode !== selectedNode && hoveredNode.show) {
      drawLabel(hoveredNode);
    }

    ctx.restore();
    
    // Schedule next animation frame only if a node is selected (for glow animation)
    if (selectedNode && !animationScheduled) {
      animationScheduled = true;
      setTimeout(() => {
        animationScheduled = false;
        requestAnimationFrame(render);
      }, 50); // ~20 FPS for smooth animation with less CPU usage
    }
  }

  /************************************************************************
   * INTERACTION HELPERS
   ************************************************************************/
  function getCanvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / (devicePixelRatio)) / rect.width;
    const y = (evt.clientY - rect.top) * (canvas.height / (devicePixelRatio)) / rect.height;
    
    const centerX = (canvas.width/(devicePixelRatio)) / 2;
    const centerY = (canvas.height/(devicePixelRatio)) / 2;
    
    const transformedX = (x - centerX - panX) / zoomLevel + centerX;
    const transformedY = (y - centerY - panY) / zoomLevel + centerY;
    
    return { x: transformedX, y: transformedY };
  }

  function findNodeAtPos(x, y) {
    if (!nodes || nodes.length === 0) return null;
    const visibleNodes = nodes.filter(n => n.show);
    
    if (selectedNode) {
      const activeSet = new Set([selectedNode.id, ...(adjacency.get(selectedNode.id) || [])]);
      const activeNodes = visibleNodes.filter(n => activeSet.has(n.id));
      for (let i = activeNodes.length - 1; i >= 0; i--) {
        const n = activeNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
      const otherNodes = visibleNodes.filter(n => !activeSet.has(n.id));
      for (let i = otherNodes.length - 1; i >= 0; i--) {
        const n = otherNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    } else {
      for (let i = visibleNodes.length - 1; i >= 0; i--) {
        const n = visibleNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    }
    return null;
  }

  function snapToGrid(x, y) {
    return {
      x: Math.round(x / CONFIG.gridSize) * CONFIG.gridSize,
      y: Math.round(y / CONFIG.gridSize) * CONFIG.gridSize
    };
  }

  function updateCanvasCursor() {
    if (isDraggingNode) {
      canvas.style.cursor = 'grabbing';
    } else if (isDragging) {
      canvas.style.cursor = 'grabbing';
    } else if (zoomLevel > 1.0) {
      canvas.style.cursor = 'grab';
    } else {
      canvas.style.cursor = 'default';
    }
  }

  /************************************************************************
   * CANVAS EVENT LISTENERS
   ************************************************************************/
  canvas.addEventListener('mousedown', (evt) => {
    if (evt.button !== 0) return;
    
    didDrag = false;
    const pos = getCanvasPos(evt);
    const n = findNodeAtPos(pos.x, pos.y);
    
    if (n) {
      mouseDownNode = n;
      mouseDownTime = Date.now();
      
      dragDelayTimer = setTimeout(() => {
        if (mouseDownNode === n) {
          // Stop physics during drag
          if (simulation) simulation.stop();
          
          // Deselect any currently selected node immediately
          selectedNode = null;
          clearInfoPanel();
          
          isDraggingNode = true;
          draggedNode = n;
          
          // Save unfixed position before dragging
          if (!n.isFixed) {
            n.unfixedX = n.x;
            n.unfixedY = n.y;
          }
          
          updateCanvasCursor();
          render();
        }
      }, CONFIG.dragDelayMs);
      
      evt.preventDefault();
    } else if (zoomLevel > 1.0) {
      // Panning canvas
      isDragging = true;
      dragStartX = evt.clientX;
      dragStartY = evt.clientY;
      dragStartPanX = panX;
      dragStartPanY = panY;
      updateCanvasCursor();
      evt.preventDefault();
    }
  });

  canvas.addEventListener('mousemove', (evt) => {
    if (isDraggingNode && draggedNode) {
      didDrag = true;
      const pos = getCanvasPos(evt);
      const snapped = snapToGrid(pos.x, pos.y);
      draggedNode.x = snapped.x;
      draggedNode.y = snapped.y;
      render();
      evt.preventDefault();
    } else if (isDragging && zoomLevel > 1.0) {
      didDrag = true;
      const deltaX = evt.clientX - dragStartX;
      const deltaY = evt.clientY - dragStartY;
      panX = dragStartPanX + deltaX / zoomLevel;
      panY = dragStartPanY + deltaY / zoomLevel;
      render();
      evt.preventDefault();
    } else {
      // Hover effect
      const pos = getCanvasPos(evt);
      const n = findNodeAtPos(pos.x, pos.y);
      if (n !== hoveredNode) {
        hoveredNode = n;
        render();
      }
    }
  });

  canvas.addEventListener('mouseup', (evt) => {
    if (dragDelayTimer) {
      clearTimeout(dragDelayTimer);
      dragDelayTimer = null;
    }
    
    if (isDraggingNode && draggedNode) {
      const snapped = snapToGrid(draggedNode.x, draggedNode.y);
      draggedNode.x = snapped.x;
      draggedNode.y = snapped.y;
      draggedNode.isFixed = true;
      draggedNode.fx = snapped.x;
      draggedNode.fy = snapped.y;
      
      schedulePhysicsRestart();
      
      isDraggingNode = false;
      draggedNode = null;
      mouseDownNode = null;
      updateCanvasCursor();
      render();
      evt.preventDefault();
      return;
    }
    
    if (isDragging) {
      isDragging = false;
      updateCanvasCursor();
      
      // Only treat as click if we didn't drag
      if (!didDrag) {
        const pos = getCanvasPos(evt);
        const n = findNodeAtPos(pos.x, pos.y);
        if (n) {
          selectedNode = n;
          populateInfoPanel(n);
          showModal(n);
          render();
        } else {
          selectedNode = null;
          clearInfoPanel();
          hideModal();
          render();
        }
      }
      evt.preventDefault();
      return;
    }
    
    if (mouseDownNode) {
      const timeSinceDown = Date.now() - mouseDownTime;
      if (timeSinceDown < CONFIG.dragDelayMs && !didDrag) {
        const pos = getCanvasPos(evt);
        const n = findNodeAtPos(pos.x, pos.y);
        if (n && n === mouseDownNode) {
          selectedNode = n;
          populateInfoPanel(n);
          showModal(n);
          render();
        }
      }
      mouseDownNode = null;
    }
  });

  canvas.addEventListener('click', (evt) => {
    if (didDrag) {
      didDrag = false;
      evt.preventDefault();
      return;
    }
    if (isDragging || isDraggingNode) return;
    const pos = getCanvasPos(evt);
    const n = findNodeAtPos(pos.x, pos.y);
    if (n) {
      selectedNode = n;
      populateInfoPanel(n);
      showModal(n);
      render();
    } else {
      selectedNode = null;
      clearInfoPanel();
      hideModal();
      render();
    }
  });

  canvas.addEventListener('mouseleave', (evt) => {
    if (dragDelayTimer) {
      clearTimeout(dragDelayTimer);
      dragDelayTimer = null;
    }
    
    isDragging = false;
    didDrag = false;
    if (isDraggingNode) {
      schedulePhysicsRestart();
    }
    isDraggingNode = false;
    draggedNode = null;
    mouseDownNode = null;
    updateCanvasCursor();
    if (hoveredNode) {
      hoveredNode = null;
      render();
    }
  });

  canvas.addEventListener('wheel', (evt) => {
    evt.preventDefault();
    if (evt.deltaY < 0) {
      zoomIn();
    } else {
      zoomOut();
    }
  });

  /************************************************************************
   * ZOOM CONTROLS
   ************************************************************************/
  function zoomIn() {
    zoomLevel = Math.min(CONFIG.zoomMax, zoomLevel + CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function zoomOut() {
    zoomLevel = Math.max(CONFIG.zoomMin, zoomLevel - CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function resetZoom() {
    zoomLevel = 1.0;
    panX = 0;
    panY = 0;
    updateCanvasCursor();
    render();
  }

  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  zoomResetBtn.addEventListener('click', resetZoom);

  /************************************************************************
   * MODAL POSITIONING AND CONTROL
   ************************************************************************/
  const infoModal = document.getElementById('info-modal');
  const modalClose = document.getElementById('modal-close');

  function getNodeScreenPosition(node) {
    const centerX = (canvas.width / devicePixelRatio) / 2;
    const centerY = (canvas.height / devicePixelRatio) / 2;
    
    // Apply the same transformation as the render function
    const worldX = node.x - centerX;
    const worldY = node.y - centerY;
    const scaledX = worldX * zoomLevel;
    const scaledY = worldY * zoomLevel;
    const screenX = scaledX + centerX + panX;
    const screenY = scaledY + centerY + panY;
    
    return { x: screenX, y: screenY };
  }

  function getConnectedNodes(node) {
    const connected = new Set();
    const nodeIds = adjacency.get(node.id) || new Set();
    nodeIds.forEach(id => {
      const connectedNode = nodeById.get(id);
      if (connectedNode) {
        connected.add(connectedNode);
      }
    });
    return Array.from(connected);
  }

  function getBoundsOfNodes(nodeList) {
    if (nodeList.length === 0) return null;
    
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    
    nodeList.forEach(node => {
      const pos = getNodeScreenPosition(node);
      minX = Math.min(minX, pos.x);
      maxX = Math.max(maxX, pos.x);
      minY = Math.min(minY, pos.y);
      maxY = Math.max(maxY, pos.y);
    });
    
    return { minX, maxX, minY, maxY, width: maxX - minX, height: maxY - minY };
  }

  function findBestModalPosition(node) {
    const connectedNodes = getConnectedNodes(node);
    const allNetworkNodes = [node, ...connectedNodes];
    const networkBounds = getBoundsOfNodes(allNetworkNodes);
    
    const modalW = MODAL_CONFIG.width;
    const modalH = MODAL_CONFIG.height;
    const padding = MODAL_CONFIG.padding;
    const canvasW = canvas.width / devicePixelRatio;
    const canvasH = canvas.height / devicePixelRatio;
    
    if (!networkBounds) {
      // Fallback to bottom-right
      return { 
        x: canvasW - modalW - padding, 
        y: canvasH - modalH - padding 
      };
    }
    
    // Try positions in order of preference
    const positions = [
      // Right of network
      { x: networkBounds.maxX + padding, y: networkBounds.minY, priority: 1 },
      // Left of network
      { x: networkBounds.minX - modalW - padding, y: networkBounds.minY, priority: 2 },
      // Below network
      { x: networkBounds.minX, y: networkBounds.maxY + padding, priority: 3 },
      // Above network
      { x: networkBounds.minX, y: networkBounds.minY - modalH - padding, priority: 4 },
      // Corners as fallback
      { x: canvasW - modalW - padding, y: padding, priority: 5 },
      { x: padding, y: padding, priority: 6 },
      { x: canvasW - modalW - padding, y: canvasH - modalH - padding, priority: 7 },
      { x: padding, y: canvasH - modalH - padding, priority: 8 }
    ];
    
    // Check if position fits and doesn't overlap
    for (let pos of positions) {
      // Clamp to canvas bounds
      const x = Math.max(padding, Math.min(canvasW - modalW - padding, pos.x));
      const y = Math.max(padding, Math.min(canvasH - modalH - padding, pos.y));
      
      // Check if this overlaps any nodes
      let overlaps = false;
      for (let n of allNetworkNodes) {
        const nodePos = getNodeScreenPosition(n);
        const nodeRadius = 30; // Extra margin
        
        if (nodePos.x + nodeRadius > x && nodePos.x - nodeRadius < x + modalW &&
            nodePos.y + nodeRadius > y && nodePos.y - nodeRadius < y + modalH) {
          overlaps = true;
          break;
        }
      }
      
      if (!overlaps) {
        return { x, y };
      }
    }
    
    // If all positions overlap, use bottom-right corner
    return { 
      x: canvasW - modalW - padding, 
      y: canvasH - modalH - padding 
    };
  }

  function adjustZoomForModal(node) {
    const connectedNodes = getConnectedNodes(node);
    const allNetworkNodes = [node, ...connectedNodes];
    
    // Get bounds in world coordinates
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    allNetworkNodes.forEach(n => {
      minX = Math.min(minX, n.x);
      maxX = Math.max(maxX, n.x);
      minY = Math.min(minY, n.y);
      maxY = Math.max(maxY, n.y);
    });
    
    const networkWidth = maxX - minX;
    const networkHeight = maxY - minY;
    const canvasW = canvas.width / devicePixelRatio;
    const canvasH = canvas.height / devicePixelRatio;
    
    // Reserve space for modal
    const availableWidth = canvasW - MODAL_CONFIG.width - MODAL_CONFIG.padding * 3;
    const availableHeight = canvasH - MODAL_CONFIG.padding * 2;
    
    // Calculate required zoom to fit network in available space
    const requiredZoomX = availableWidth / (networkWidth + 200); // Add padding
    const requiredZoomY = availableHeight / (networkHeight + 200);
    const requiredZoom = Math.min(requiredZoomX, requiredZoomY);
    
    // Only zoom out if current zoom is too high
    if (requiredZoom < zoomLevel) {
      zoomLevel = Math.max(CONFIG.zoomMin, requiredZoom * 0.9);
      render();
    }
  }

  function showModal(node) {
    savedZoomBeforeModal = { zoom: zoomLevel, panX: panX, panY: panY };
    
    // Try to zoom/position to fit the modal and network
    adjustZoomForModal(node);
    
    // Find best position
    const pos = findBestModalPosition(node);
    
    // Position the modal
    infoModal.style.left = pos.x + 'px';
    infoModal.style.top = pos.y + 'px';
    infoModal.style.right = 'auto';
    infoModal.style.bottom = 'auto';
    infoModal.classList.add('visible');
  }

  function hideModal() {
    infoModal.classList.remove('visible');
    
    // Restore original zoom
    if (savedZoomBeforeModal) {
      zoomLevel = savedZoomBeforeModal.zoom;
      panX = savedZoomBeforeModal.panX;
      panY = savedZoomBeforeModal.panY;
      savedZoomBeforeModal = null;
      render();
    }
  }

  modalClose.addEventListener('click', () => {
    selectedNode = null;
    hideModal();
    clearInfoPanel();
    render();
    searchInput.value = '';
    suggestionsEl.style('display', 'none').html('');
    msgEl.text('');
  });

  /************************************************************************
   * INFO PANEL
   ************************************************************************/
  function normalizeUrl(u) {
    if (!u) return null;
    const s = String(u).trim();
    if (s === '') return null;
    if (/^[a-zA-Z][a-zA-Z0-9+\-.]*:\/\//.test(s)) return s;
    return 'https://' + s.replace(/^[\/]+/, '');
  }

  function populateInfoPanel(d) {
    const desc = (d.raw && (d.raw['Description'] || '')) || '';
    const category = (d.raw && (d.raw['Category'] || '')) || '';

    const rawLink = (d.raw && (d.raw['Link'] || d.raw['Link '])) || '';
    const safe = normalizeUrl(rawLink);
    const rawMoreInfo = (d.raw && (d.raw['More Info'] || d.raw['More Info'])) || '';
    const safeMoreInfo = normalizeUrl(rawMoreInfo);

    let links = [];
    if (safe) links.push(`<a href="${safe}" target="_blank" rel="noopener">More Info</a>`);
    if (safeMoreInfo) links.push(`<a href="${safeMoreInfo}" target="_blank" rel="noopener">More Info</a>`);
    const linksHTML = links.length > 0 ? links.join(' | ') : '';

    nodeTitleEl.html(`
      <div style="display:flex; align-items:center; gap:8px; font-size:24px; font-weight:700;">
        <span>${d.name}</span>
        ${d.image ? `<img src="${d.image}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;">` : ''}
      </div>
      ${category ? `<div style="font-size: 15px; font-weight: bold; margin-top: 6px;">${category.replace(/\n/g, '<br>')}</div>` : ''}
      ${desc ? `<div style="font-size: 13px; font-weight: normal;">${desc}</div>` : ''}
      ${linksHTML ? `<div style="margin-top: 8px;">${linksHTML}</div>` : ''}
      <div style="font-size: 14px; font-weight: bold; margin-top: 6px;">
        <br>
        <br>Connected to: 
      </div>
    `);

    nodeLinkEl.html('');

    const conns = Array.from(adjacency.get(d.id) || []).slice();
    conns.sort((a,b) => a.localeCompare(b, undefined, {sensitivity:'base'}));
    connectionsBox.innerHTML = '';
    if (conns.length === 0) {
      connectionsBox.innerHTML = '<div class="muted">No connections</div>';
      return;
    }
    const frag = document.createDocumentFragment();
    const nodeSourceMap = connectionSources.get(d.id);
    conns.forEach(name => {
      const item = document.createElement('div');
      item.className = 'conn-item';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.justifyContent = 'space-between';
      item.style.gap = '8px';
      
      const nameSpan = document.createElement('span');
      nameSpan.textContent = name;
      nameSpan.style.flex = '1';
      nameSpan.style.cursor = 'pointer';
      nameSpan.addEventListener('click', () => {
        const targetNode = nodeById.get(name);
        if (targetNode) {
          selectedNode = targetNode;
          populateInfoPanel(targetNode);
          showModal(targetNode);
          render();
          connectionsBox.scrollTop = 0;
        }
      });
      item.appendChild(nameSpan);
      
      const sourceUrl = nodeSourceMap ? nodeSourceMap.get(name) : null;
      if (sourceUrl) {
        const sourceIcon = document.createElement('a');
        sourceIcon.href = normalizeUrl(sourceUrl) || '#';
        sourceIcon.target = '_blank';
        sourceIcon.rel = 'noopener';
        sourceIcon.innerHTML = '🔗';
        sourceIcon.style.fontSize = '16px';
        sourceIcon.style.textDecoration = 'none';
        sourceIcon.style.cursor = 'pointer';
        sourceIcon.style.flexShrink = '0';
        sourceIcon.title = 'View source';
        sourceIcon.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        item.appendChild(sourceIcon);
      }
      
      frag.appendChild(item);
    });
    connectionsBox.appendChild(frag);
  }

  function clearInfoPanel() {
    nodeTitleEl.html('Select a node to view details');
    nodeMetaEl.text('');
    nodeLinkEl.html('');
    connectionsBox.innerHTML = '';
  }

  /************************************************************************
   * SEARCH
   ************************************************************************/
  searchInput.addEventListener('input', onSearchInput);
  searchBtn.addEventListener('click', () => performSearch(searchInput.value.trim()));
  searchInput.addEventListener('keydown', (ev) => { 
    if (ev.key === 'Enter') { 
      performSearch(searchInput.value.trim()); 
      ev.preventDefault(); 
    } 
  });

  function onSearchInput() {
    const q = searchInput.value.trim();
    suggestionsEl.style('display', 'none').html('');
    msgEl.text('');
    if (!q || q.length < 3) return;
    const term = q.toLowerCase();
    const matches = [];
    for (const name of nameIndex) {
      if (name && name.toLowerCase().includes(term)) matches.push(name);
      if (matches.length >= CONFIG.maxSuggestions) break;
    }
    if (matches.length === 0) {
      suggestionsEl.style('display','block').html('<div class="muted">No suggestions</div>');
      return;
    }
    suggestionsEl.style('display','block').html('');
    matches.forEach(m => {
      suggestionsEl.append('div').attr('class','suggestion').text(m).on('click', () => {
        searchInput.value = m;
        suggestionsEl.style('display','none').html('');
        performSearch(m);
      });
    });
  }

  function performSearch(q) {
    if (!q) return;
    const exact = nodes.find(n => n.name && n.name.toLowerCase() === q.toLowerCase());
    if (exact) {
      selectedNode = exact; 
      populateInfoPanel(exact);
      showModal(exact); 
      render(); 
      msgEl.text(''); 
      return;
    }
    const matches = nodes.filter(n => n.name && n.name.toLowerCase().includes(q.toLowerCase()));
    if (matches.length === 1) {
      selectedNode = matches[0]; 
      populateInfoPanel(matches[0]);
      showModal(matches[0]); 
      render(); 
      msgEl.text(''); 
      return;
    } else if (matches.length > 1) {
      suggestionsEl.style('display','block').html('');
      matches.slice(0, CONFIG.maxSuggestions).forEach(m => {
        suggestionsEl.append('div').attr('class','suggestion').text(m.name).on('click', () => {
          searchInput.value = m.name;
          suggestionsEl.style('display','none').html('');
          selectedNode = m;
          populateInfoPanel(m);
          showModal(m);
          render();
        });
      });
      msgEl.text('Multiple matches — click a suggestion.'); 
      return;
    } else {
      msgEl.text('Search term not found. Please try again.');
    }
  }

  /************************************************************************
   * INITIALIZE
   ************************************************************************/
  render();
  autoLoadData();
  </script>
</body>
</html>